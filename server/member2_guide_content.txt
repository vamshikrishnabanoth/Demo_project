

Member 2: Quiz Management & AI Integration -
Complete Guide
Your Name: _________________
Role: Quiz Management & AI Integration Specialist
Complexity Level: (4/5)
Presentation Time: 15 minutes
Table of Contents
Your Role Overview
Technologies You Need to Master
Complete Code Walkthrough
Learning Path (Step-by-Step)
Your Files - Detailed Breakdown
How Everything Works Together
Presentation Structure
Practice Questions & Answers
Demo Script
Troubleshooting Guide
Your Role Overview
What You're Responsible For
You are the brain behind quiz creation in this Kahoot clone. Your system allows teachers to create quizzes
in 3 different ways:
Manual Entry - Teachers type questions manually
Topic-Based AI Generation - AI creates questions from a topic (e.g., "Photosynthesis")
File Upload AI Generation - AI extracts content from DOCX files and generates questions
Why This Role is Important
Without your component, teachers would have no way to create quizzes. You're integrating cutting-edge
AI technology (Google's Gemini AI) to make quiz creation 10x faster and easier.
Key Responsibilities
• Handle quiz CRUD operations (Create, Read, Update, Delete)

• Integrate Google Generative AI (Gemini) for question generation
• Process file uploads (DOCX) and extract text
• Validate quiz data and ensure data integrity
• Provide API endpoints for the frontend
Technologies You Need to Master
1. **Node.js & Express.js** (Backend Framework)
What it is: JavaScript runtime for building server-side applications
Why we use it: To create REST API endpoints that the frontend calls
Key Concepts to Learn:
• Request/Response cycle
• Middleware functions
• Routing
• Async/await for asynchronous operations
Resources:
• Express.js Official Docs
• Node.js Crash Course (YouTube - 1.5 hours)
2. **MongoDB & Mongoose** (Database)
What it is: NoSQL database and ODM (Object Data Modeling) library
Why we use it: To store quiz data persistently
Key Concepts to Learn:
• Document-based databases
• Schemas and models
• CRUD operations with Mongoose
• References between collections
Resources:
• MongoDB University (Free courses)
• Mongoose Docs
3. **Google Generative AI (Gemini)** (AI Integration)
What it is: Google's advanced AI model for text generation
Why we use it: To automatically generate quiz questions from topics or documents

Key Concepts to Learn:
• API authentication with API keys
• Prompt engineering (how to write effective prompts)
• JSON parsing from AI responses
• Error handling for AI failures
Resources:
• Google AI Studio
• Gemini API Quickstart
4. **Multer** (File Upload Middleware)
What it is: Node.js middleware for handling multipart/form-data (file uploads)
Why we use it: To receive DOCX files from the frontend
Key Concepts to Learn:
• File upload handling
• Memory storage vs disk storage
• File validation (MIME types, size limits)
Resources:
• Multer Documentation
5. **Mammoth.js** (DOCX Text Extraction)
What it is: Library to extract text from DOCX files
Why we use it: To read content from uploaded Word documents
Key Concepts to Learn:
• Buffer handling
• Text extraction from binary files
• Cleaning extracted text
Resources:
• Mammoth.js GitHub
6. **RESTful API Design**
What it is: Architectural style for designing web APIs
Why we use it: To create clean, predictable API endpoints
Key Concepts to Learn:
• HTTP methods (GET, POST, PUT, DELETE)

• Status codes (200, 201, 400, 404, 500)
• Request/response formats (JSON)
• Route naming conventions
Resources:
• REST API Tutorial
Complete Code Walkthrough
Architecture Overview
Frontend (CreateQuiz.jsx)
    ↓ HTTP Request
Backend API (quizRoutes.js)
    ↓ Route to Controller
Controller (quizController.js)
    ↓ Business Logic
AI Service (aiGenerator.js) ← Calls Gemini API
    ↓ Generated Questions
Database (Quiz.js model)
    ↓ Save to MongoDB
Response back to Frontend
Your Files - Detailed Breakdown
File 1: `backend/models/Quiz.js` (Database Schema)
Location: c:\Users\vamsh\Downloads\Kahoot\Kahoot\backend\models\Quiz.js
Lines of Code: 105
Purpose: Defines the structure of quiz data in MongoDB
Complete Code Explanation
const mongoose = require('mongoose');
// Sub-schema for individual questions
const questionSchema = new mongoose.Schema({
    questionText: {
        type: String,
        required: true, // Every question must have text
    },
    options: {
        type: [String], // Array of 4 strings
        required: true,
        validate: [opt => opt.length >= 2, 'At least two options required'],
    },
    correctAnswer: {
        type: String,
        required: true, // Must specify which option is correct
    },
    timer: {
        type: Number,
        default: 30, // Default 30 seconds per question
    },
    points: {
        type: Number,
        default: 10, // Default 10 points per question
    }
});
// Main Quiz schema

const quizSchema = new mongoose.Schema({
    title: {
        type: String,
        required: [true, 'Please add a quiz title'],
        trim: true, // Removes whitespace
    },
    description: {
        type: String,
    },
    creator: {
        type: mongoose.Schema.Types.ObjectId, // Reference to User model
        ref: 'User',
        required: true,
    },
    quizType: {
        type: String,
        enum: ['manual', 'topic', 'file'], // Only these 3 values allowed
        default: 'manual',
    },
    topicInfo: {
        topic: String,
        difficulty: {
            type: String,
            enum: ['easy', 'medium', 'hard'],
        },
        numQuestions: Number,
    },
    fileInfo: {
        fileName: String,
        fileUrl: String,
    },
    questions: [questionSchema], // Array of question objects
    gameCode: {
        type: String,
        unique: true, // No duplicates allowed
        required: true,
    },
    isPublished: {
        type: Boolean,
        default: false,
    },
    createdAt: {
        type: Date,
        default: Date.now,
    },
});
module.exports = mongoose.model('Quiz', quizSchema);
Key Points to Understand
Embedded vs Referenced Documents
- questions are embedded (stored inside the quiz document)
- creator is referenced (stores only the User ID, not the whole user object)
Validation
- required: true - Field must be provided
- unique: true - No two documents can have the same value
- enum - Only specific values are allowed
- Custom validators like validate: [opt => opt.length >= 2, ...]
Default Values
- timer: 30 - If not provided, defaults to 30
- createdAt: Date.now - Automatically set to current time

File 2: `backend/controllers/quizController.js` (Business Logic)
Location: c:\Users\vamsh\Downloads\Kahoot\Kahoot\backend\controllers\quizController.js
Lines of Code: 170
Purpose: Handles all quiz-related operations
Function-by-Function Breakdown
1. `generateQuestions()` - AI Question Generation
exports.generateQuestions = async (req, res) => {
    try {
        console.log(">>> [CONTROLLER] generateQuestions HIT");
        const { mode, topic, difficulty, numQuestions } = req.body;
        const file = req.file; // From multer middleware
        let generatedQuestions = [];
        if (mode === 'topic') {
            if (!topic) return res.status(400).json({ message: 'Topic is required' });
            generatedQuestions = await generateQuestionsFromTopic(topic, numQuestions, difficulty);
        } else if (mode === 'file') {
            if (!file) return res.status(400).json({ message: 'File is required' });
            generatedQuestions = await generateQuestionsFromFile(file, numQuestions);
        } else {
            return res.status(400).json({ message: 'Invalid generation mode' });
        }
        res.json({ questions: generatedQuestions });
    } catch (error) {
        console.error("Generation Controller Error:", error);
        res.status(500).json({ message: error.message });
    }
};
What it does:
• Receives a request to generate questions
• Checks if mode is 'topic' or 'file'
• Calls the appropriate AI generation function
• Returns generated questions as JSON
Flow:
Frontend sends POST request to /api/quizzes/generate
Multer middleware processes file upload (if any)
Controller extracts mode, topic, difficulty, numQuestions from request body
Calls AI service function
Returns generated questions
2. `generateGameCode()` - Unique Code Generator
const generateGameCode = async () => {
    let code;
    let exists = true;
    while (exists) {
        // Generate random 6-digit number
        code = Math.floor(100000 + Math.random() * 900000).toString();
        // Check if code already exists in database
        const quiz = await Quiz.findOne({ gameCode: code });
        if (!quiz) exists = false; // Code is unique
    }
    return code;
};

What it does:
• Generates a random 6-digit game code (e.g., "482719")
• Checks if it already exists in the database
• Keeps generating until it finds a unique code
Why it's important:
• Students use this code to join live games
• Must be unique to avoid conflicts
3. `createQuiz()` - Save Quiz to Database
exports.createQuiz = async (req, res) => {
    try {
        const { title, description, quizType, questions, topicInfo, fileInfo } = req.body;
        const gameCode = await generateGameCode();
        const quiz = await Quiz.create({
            title,
            description,
            quizType,
            questions,
            topicInfo,
            fileInfo,
            gameCode,
            creator: req.user._id, // From auth middleware
        });
        res.status(201).json(quiz);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
What it does:
• Receives quiz data from frontend
• Generates a unique game code
• Saves quiz to MongoDB
• Returns the created quiz with status 201 (Created)
Important:
• req.user._id comes from the authentication middleware
• This ensures the quiz is linked to the logged-in teacher
4. `getMyQuizzes()` - Fetch Teacher's Quizzes
exports.getMyQuizzes = async (req, res) => {
    try {
        const quizzes = await Quiz.find({ creator: req.user._id });
        res.json(quizzes);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
What it does:

• Finds all quizzes created by the logged-in teacher
• Returns them as an array
5. `getQuizByCode()` - Student Joins Game
exports.getQuizByCode = async (req, res) => {
    try {
        const quiz = await Quiz.findOne({
            gameCode: req.params.gameCode,
            isPublished: true
        });
        if (!quiz) {
            return res.status(404).json({ message: 'Quiz not found or not published' });
        }
        res.json(quiz);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
What it does:
• Students enter a 6-digit code
• Finds the quiz with that code
• Only returns if isPublished: true
6. `updateQuiz()` - Edit Existing Quiz
exports.updateQuiz = async (req, res) => {
    try {
        let quiz = await Quiz.findById(req.params.id);
        if (!quiz) {
            return res.status(404).json({ message: 'Quiz not found' });
        }
        // Security check: Only creator can update
        if (quiz.creator.toString() !== req.user._id.toString()) {
            return res.status(401).json({ message: 'User not authorized' });
        }
        quiz = await Quiz.findByIdAndUpdate(req.params.id, req.body, { new: true });
        res.json(quiz);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
What it does:
• Finds quiz by ID
• Verifies the user is the creator
• Updates the quiz
• Returns updated quiz
7. `deleteQuiz()` - Remove Quiz
exports.deleteQuiz = async (req, res) => {
    try {
        const quiz = await Quiz.findById(req.params.id);
        if (!quiz) {
            return res.status(404).json({ message: 'Quiz not found' });
        }
        if (quiz.creator.toString() !== req.user._id.toString()) {

            return res.status(401).json({ message: 'User not authorized' });
        }
        await quiz.deleteOne();
        res.json({ message: 'Quiz removed' });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
What it does:
• Finds quiz by ID
• Verifies ownership
• Deletes from database
File 3: `backend/routes/quizRoutes.js` (API Endpoints)
Location: c:\Users\vamsh\Downloads\Kahoot\Kahoot\backend\routes\quizRoutes.js
Lines of Code: 54
Purpose: Defines URL routes and connects them to controller functions
Complete Route Mapping
const express = require('express');
const router = express.Router();
const multer = require('multer');
const {
    createQuiz,
    getMyQuizzes,
    getQuizByCode,
    getQuizById,
    updateQuiz,
    deleteQuiz,
    generateQuestions,
} = require('../controllers/quizController');
const { protect, authorize } = require('../middleware/authMiddleware');
// Configure Multer for file uploads (stores in memory as buffer)
const upload = multer({ storage: multer.memoryStorage() });
// POST /api/quizzes/generate - AI question generation
router.post('/generate', protect, authorize('faculty', 'admin'), upload.single('file'), generateQuestions);
// POST /api/quizzes - Create new quiz
router.post('/', protect, authorize('faculty', 'admin'), createQuiz);
// GET /api/quizzes/my-quizzes - Get teacher's quizzes
router.get('/my-quizzes', protect, authorize('faculty', 'admin'), getMyQuizzes);
// GET /api/quizzes/join/:gameCode - Student joins game (PUBLIC)
router.get('/join/:gameCode', getQuizByCode);
// GET /api/quizzes/:id - Get single quiz by ID
router.get('/:id', protect, authorize('faculty', 'admin'), getQuizById);
// PUT /api/quizzes/:id - Update quiz
router.put('/:id', protect, authorize('faculty', 'admin'), updateQuiz);
// DELETE /api/quizzes/:id - Delete quiz
router.delete('/:id', protect, authorize('faculty', 'admin'), deleteQuiz);
module.exports = router;
Understanding Middleware Chain
Each route can have multiple middleware functions:
router.post('/generate', protect, authorize('faculty', 'admin'), upload.single('file'), generateQuestions);

Execution order:
protect - Verifies JWT token, adds req.user
authorize('faculty', 'admin') - Checks if user role is faculty or admin
upload.single('file') - Processes file upload, adds req.file
generateQuestions - Final controller function
File 4: `backend/utils/aiGenerator.js` (AI Integration)
Location: c:\Users\vamsh\Downloads\Kahoot\Kahoot\backend\utils\aiGenerator.js
Lines of Code: 120
Purpose: Communicates with Google Gemini AI to generate questions
Function 1: `generateQuestionsFromTopic()`
const generateQuestionsFromTopic = async (topic, numQuestions = 5, difficulty = 'medium') => {
    try {
        // Create the prompt for AI
        const prompt = `Generate ${numQuestions} multiple-choice questions about "${topic}" at a ${difficulty} difficulty level.
        Each question must have 4 options and 1 correct answer.
        Return ONLY a JSON array in the following format:
        [{"questionText": "...", "options": ["...", "...", "...", "..."], "correctAnswer": "...", "timer": 30, "points": 10}]`;
        // Send request to Gemini API
        const response = await axios.post(BASE_URL, {
            contents: [{ parts: [{ text: prompt }] }]
        });
        // Extract response text
        const text = response.data.candidates[0].content.parts[0].text;
        // Parse JSON from response
        const json = extractJson(text);
        if (!json) throw new Error("Invalid AI response");
        return json;
    } catch (error) {
        throw new Error(`AI generation failed: ${error.message}`);
    }
};
How it works:
Prompt Engineering: Creates a detailed instruction for the AI
API Call: Sends HTTP POST request to Gemini API
Response Parsing: Extracts JSON array from AI's text response
Error Handling: Catches and reports any failures
Example API Response:
[
  {
    "questionText": "What is photosynthesis?",
    "options": [
      "Process of making food using sunlight",
      "Process of breathing",
      "Process of cell division",
      "Process of digestion"
    ],
    "correctAnswer": "Process of making food using sunlight",
    "timer": 30,
    "points": 10

  }
]
Function 2: `generateQuestionsFromFile()`
const generateQuestionsFromFile = async (file, numQuestions = 5) => {
    try {
        let textContent = '';
        const mimeType = file.mimetype.toLowerCase();
        // Extract text based on file type
        if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
            // Use mammoth for DOCX
            const result = await mammoth.extractRawText({ buffer: file.buffer });
            textContent = result.value;
        } else {
            throw new Error(`Unsupported file type: ${file.mimetype}`);
        }
        // Validate extracted text
        if (!textContent || textContent.trim().length < 50) {
            throw new Error("File doesn't contain enough text");
        }
        // Clean and limit text size
        const cleanText = textContent.replace(/\s+/g, ' ').substring(0, 10000);
        // Create prompt with document context
        const prompt = `Based on the following document, generate ${numQuestions} questions.
        Context: ${cleanText}
        Return ONLY a JSON array: [{"questionText": "...", "options": [...], "correctAnswer": "...", "timer": 30, "points": 10}]`;
        // Call Gemini API
        const response = await axios.post(BASE_URL, {
            contents: [{ parts: [{ text: prompt }] }]
        });
        const text = response.data.candidates[0].content.parts[0].text;
        const json = extractJson(text);
        return json;
    } catch (error) {
        throw new Error(`File generation failed: ${error.message}`);
    }
};
How it works:
File Type Detection: Checks MIME type
Text Extraction: Uses Mammoth.js to extract text from DOCX
Text Cleaning: Removes extra whitespace, limits to 10,000 characters
AI Processing: Sends document content to Gemini
Question Generation: AI creates questions based on document content
Helper Function: `extractJson()`
const extractJson = (text) => {
    try {
        // Find JSON array or object in text using regex
        const jsonMatch = text.match(/\[[\s\S]*\]|\{[\s\S]*\}/);
        if (!jsonMatch) return null;
        return JSON.parse(jsonMatch[0].trim());
    } catch (e) {
        return null;
    }
};
Why it's needed:

• AI sometimes returns extra text like "Here are your questions: [...]"
• This function extracts only the JSON part
• Uses regex to find [...] or {...} patterns
File 5: `frontend/src/pages/faculty/CreateQuiz.jsx` (UI Component)
Location: c:\Users\vamsh\Downloads\Kahoot\Kahoot\frontend\src\pages\faculty\CreateQuiz.jsx
Lines of Code: 398
Purpose: User interface for quiz creation
Key React Concepts Used
1. State Management with `useState`
const [title, setTitle] = useState('');
const [description, setDescription] = useState('');
const [quizType, setQuizType] = useState('manual'); // 'manual', 'topic', 'file'
const [topic, setTopic] = useState('');
const [difficulty, setDifficulty] = useState('medium');
const [numQuestions, setNumQuestions] = useState(5);
const [file, setFile] = useState(null);
const [questions, setQuestions] = useState([
    { questionText: '', options: ['', '', '', ''], correctAnswer: '', timer: 30, points: 10 }
]);
const [loading, setLoading] = useState(false);
const [isGenerating, setIsGenerating] = useState(false);
What is state?
• State is data that can change over time
• When state changes, React re-renders the component
• useState returns [value, setValue]
2. AI Generation Handler
const handleGenerate = async () => {
    if (quizType === 'topic' && !topic) return alert('Please enter a topic');
    if (quizType === 'file' && !file) return alert('Please select a file');
    setIsGenerating(true);
    try {
        const formData = new FormData();
        formData.append('mode', quizType);
        formData.append('numQuestions', numQuestions);
        if (quizType === 'topic') {
            formData.append('topic', topic);
            formData.append('difficulty', difficulty);
        } else {
            formData.append('file', file);
        }
        const response = await api.post('/quizzes/generate', formData);
        setQuestions(response.data.questions);
        alert('AI generated your quiz!');
    } catch (error) {
        alert(error.response?.data?.message || 'Generation failed');
    } finally {
        setIsGenerating(false);
    }
};
What it does:

Validates input (topic or file must be provided)
Creates FormData object (required for file uploads)
Sends POST request to /api/quizzes/generate
Updates questions state with AI-generated questions
Shows success/error message
3. Quiz Submission Handler
const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    // Validate all questions are complete
    const isValid = questions.every(q =>
        q.questionText && q.correctAnswer && q.options.every(o => o)
    );
    if (!isValid) {
        alert('Please fill in all questions');
        setLoading(false);
        return;
    }
    try {
        await api.post('/quizzes', {
            title,
            description,
            quizType,
            questions
        });
        navigate('/faculty/dashboard');
    } catch (error) {
        alert('Failed to create quiz');
    } finally {
        setLoading(false);
    }
};
What it does:
Prevents default form submission
Validates all questions are complete
Sends quiz data to backend
Navigates back to dashboard on success
How Everything Works Together
Complete Flow: Topic-Based Quiz Creation
1. Teacher opens CreateQuiz page
   ↓
2. Selects "Topic" mode
   ↓
3. Enters topic: "Photosynthesis"
   ↓
4. Sets difficulty: "Medium"
   ↓
5. Sets number of questions: 5
   ↓
6. Clicks "Generate with AI"
   ↓
7. Frontend sends POST to /api/quizzes/generate
   {

     mode: "topic",
     topic: "Photosynthesis",
     difficulty: "medium",
     numQuestions: 5
   }
   ↓
8. Backend receives request in quizController.js
   ↓
9. Calls generateQuestionsFromTopic() in aiGenerator.js
   ↓
10. Sends prompt to Google Gemini API
    "Generate 5 medium difficulty questions about Photosynthesis..."
   ↓
11. Gemini AI processes and returns JSON
    [
      {
        "questionText": "What is photosynthesis?",
        "options": ["...", "...", "...", "..."],
        "correctAnswer": "...",
        "timer": 30,
        "points": 10
      },
      ...
    ]
   ↓
12. Backend sends questions back to frontend
   ↓
13. Frontend displays questions in editable form
   ↓
14. Teacher reviews and edits if needed
   ↓
15. Teacher clicks "Save"
   ↓
16. Frontend sends POST to /api/quizzes
    {
      title: "Photosynthesis Quiz",
      description: "...",
      quizType: "topic",
      questions: [...]
    }
   ↓
17. Backend creates quiz in database
    - Generates unique game code
    - Links to teacher's user ID
    - Saves to MongoDB
   ↓
18. Returns created quiz with status 201
   ↓
19. Frontend navigates to dashboard
   ↓
20. Teacher sees new quiz in their list
Complete Flow: File-Based Quiz Creation
1. Teacher selects "File" mode
   ↓
2. Uploads a DOCX file about "Cell Biology"
   ↓
3. Clicks "Generate with AI"
   ↓
4. Frontend creates FormData with file
   ↓
5. Sends POST to /api/quizzes/generate
   ↓
6. Multer middleware processes file upload
   - Stores file in memory as buffer
   - Adds to req.file
   ↓
7. quizController calls generateQuestionsFromFile()
   ↓
8. Mammoth.js extracts text from DOCX
   "Cells are the basic unit of life..."
   ↓
9. Text is cleaned and limited to 10,000 characters
   ↓
10. Sends to Gemini API with document context
    "Based on this document, generate 5 questions..."
   ↓

11. AI analyzes document and creates questions
   ↓
12. Questions returned to frontend
   ↓
13. Teacher reviews and saves
Learning Path (Step-by-Step)
Week 1: Foundations (10-15 hours)
Day 1-2: JavaScript & Node.js Basics
• [ ] Review JavaScript ES6+ features (arrow functions, async/await, destructuring)
• [ ] Learn about Promises and asynchronous programming
• [ ] Understand Node.js event loop
Resources:
• JavaScript.info - Modern JavaScript Tutorial
• Node.js Crash Course
Day 3-4: Express.js & REST APIs
• [ ] Create a simple Express server
• [ ] Understand middleware concept
• [ ] Learn about routing and HTTP methods
• [ ] Practice with Postman for API testing
Practice Exercise:
Create a simple TODO API with these endpoints:
• GET /todos - Get all todos
• POST /todos - Create a todo
• PUT /todos/:id - Update a todo
• DELETE /todos/:id - Delete a todo
Day 5-7: MongoDB & Mongoose
• [ ] Install MongoDB locally or use MongoDB Atlas (cloud)
• [ ] Learn Mongoose schema definition
• [ ] Practice CRUD operations
• [ ] Understand references and population
Practice Exercise:
Create a Book schema with:
• title (String, required)

• author (String, required)
• pages (Number)
• published (Date)
Then create functions to:
• Add a book
• Find all books
• Update a book
• Delete a book
Week 2: AI Integration & File Handling (10-15 hours)
Day 1-3: Google Generative AI
• [ ] Get a Gemini API key from Google AI Studio
• [ ] Learn about prompt engineering
• [ ] Practice making API calls with axios
• [ ] Handle JSON parsing from AI responses
Practice Exercise:
Create a simple script that:
Takes a topic as input
Sends it to Gemini API
Asks AI to generate 3 quiz questions
Parses and displays the questions
Day 4-5: File Upload with Multer
• [ ] Learn about multipart/form-data
• [ ] Configure Multer for file uploads
• [ ] Understand memory storage vs disk storage
• [ ] Validate file types and sizes
Practice Exercise:
Create an endpoint that:
Accepts image uploads
Validates file type (only .jpg, .png)
Limits file size to 5MB
Returns file information
Day 6-7: Text Extraction with Mammoth
• [ ] Install Mammoth.js

• [ ] Extract text from DOCX files
• [ ] Clean and process extracted text
• [ ] Handle errors (corrupted files, empty files)
Practice Exercise:
Create a function that:
Takes a DOCX file buffer
Extracts all text
Counts words
Returns first 100 words
Week 3: Integration & Testing (10-15 hours)
Day 1-3: Study Your Codebase
• [ ] Read through all 5 files line by line
• [ ] Add comments explaining each section
• [ ] Trace the flow from frontend to backend
• [ ] Identify how each function connects
Day 4-5: Test Everything
• [ ] Set up the project locally
• [ ] Test manual quiz creation
• [ ] Test topic-based generation
• [ ] Test file-based generation
• [ ] Test quiz editing and deletion
Day 6-7: Prepare Presentation
• [ ] Create slides (10-12 slides)
• [ ] Prepare code snippets
• [ ] Practice demo
• [ ] Prepare for Q&A;
Presentation Structure
Slide 1: Title Slide (30 seconds)
Content:
• Your name
• Role: Quiz Management & AI Integration

• Technologies: Node.js, Express, MongoDB, Google Gemini AI
Slide 2: Role Overview (1 minute)
Content:
• What you're responsible for
• Why it's important
• 3 quiz creation methods
Speaking Points:
"I'm responsible for the quiz creation system, which is the core of our application. Teachers can create
quizzes in three ways: manually typing questions, using AI to generate from a topic, or uploading a
document for AI processing."
Slide 3: Architecture Diagram (2 minutes)
Content:
• Show the flow diagram (Frontend Routes Controller AI Service Database)
• Highlight your components
Speaking Points:
"When a teacher creates a quiz, the request flows through our Express routes, gets processed by the
controller, optionally calls the AI service, and finally saves to MongoDB. Let me walk you through each
layer..."
Slide 4: Database Schema (2 minutes)
Content:
• Show Quiz model structure
• Explain key fields
• Show sample document
Speaking Points:
"Our Quiz model has several important fields. The questions array stores all the quiz questions, each with
options, correct answer, timer, and points. The gameCode is a unique 6-digit code that students use to
join..."
Show Code:
{
  title: "Photosynthesis Quiz",
  gameCode: "482719",
  questions: [
    {
      questionText: "What is photosynthesis?",
      options: ["...", "...", "...", "..."],
      correctAnswer: "...",
      timer: 30,
      points: 10
    }
  ]

}
Slide 5: AI Integration - Topic-Based (3 minutes)
Content:
• Show generateQuestionsFromTopic() function
• Explain prompt engineering
• Show sample API request/response
Speaking Points:
"The most exciting part is our AI integration. When a teacher enters a topic like 'Photosynthesis', we send a
carefully crafted prompt to Google's Gemini AI. The prompt specifies exactly what we need: multiple-choice
questions with 4 options each..."
Show Code:
const prompt = `Generate 5 questions about "Photosynthesis" at medium difficulty.
Return ONLY a JSON array: [{"questionText": "...", "options": [...], ...}]`;
const response = await axios.post(GEMINI_API_URL, {
  contents: [{ parts: [{ text: prompt }] }]
});
Slide 6: AI Integration - File-Based (2 minutes)
Content:
• Show file upload flow
• Explain text extraction with Mammoth
• Show how document content is sent to AI
Speaking Points:
"For file-based generation, we use Multer to handle the file upload, then Mammoth.js extracts the text from
DOCX files. We clean the text, limit it to 10,000 characters, and send it to Gemini AI as context for question
generation..."
Slide 7: API Endpoints (1 minute)
Content:
• List all quiz routes
• Explain REST conventions
• Show middleware chain
Speaking Points:
"We have 7 main API endpoints. Each route uses middleware for authentication and authorization. For
example, the generate endpoint requires the user to be logged in as faculty, and uses Multer to process file
uploads..."

Show:
POST   /api/quizzes/generate    - Generate questions with AI
POST   /api/quizzes             - Create quiz
GET    /api/quizzes/my-quizzes  - Get teacher's quizzes
GET    /api/quizzes/join/:code  - Student joins game
PUT    /api/quizzes/:id         - Update quiz
DELETE /api/quizzes/:id         - Delete quiz
Slide 8: Error Handling (1 minute)
Content:
• Show try-catch blocks
• Explain validation
• Show error responses
Speaking Points:
"We have comprehensive error handling. If the AI fails, we catch the error and send a meaningful message
to the user. We also validate all inputs - for example, checking that a topic is provided for topic-based
generation..."
Slide 9: Live Demo (3 minutes)
Content:
• Open the application
• Create a quiz using AI (topic-based)
• Show the generated questions
• Save the quiz
Demo Script:
"Let me show you how this works in practice..."
Navigate to Create Quiz page
Select "Topic" mode
Enter topic: "JavaScript Promises"
Click "Generate with AI"
Show loading state
Show generated questions
Edit one question to show it's editable
Click Save
Show quiz in dashboard with game code
Slide 10: Challenges & Solutions (1 minute)
Content:

• Challenge 1: AI sometimes returns invalid JSON
- Solution: Created extractJson() helper with regex
• Challenge 2: Large files crash the system
- Solution: Limit text to 10,000 characters
• Challenge 3: Duplicate game codes
- Solution: Loop until unique code is found
Slide 11: What I Learned (1 minute)
Content:
• Prompt engineering for AI
• File processing in Node.js
• RESTful API design
• MongoDB schema design
• Error handling best practices
Slide 12: Q&A; (Remaining time)
Content:
• "Thank you! Any questions?"
Practice Questions & Answers
Technical Questions
Q1: How does the AI know what format to return the questions in?
A: We use prompt engineering. In our prompt, we explicitly tell the AI to return a JSON array with a specific
structure. For example:
const prompt = `Return ONLY a JSON array in this format:
[{"questionText": "...", "options": ["...", "...", "...", "..."], "correctAnswer": "...", "timer": 30, "points": 10}]`;
The AI is trained to follow instructions, so it returns data in the requested format. We also have a
extractJson() helper function that uses regex to extract the JSON part even if the AI adds extra text.
Q2: What happens if two teachers generate the same game code at the same time?
A: This is handled by our generateGameCode() function. It uses a while loop to keep generating random
codes until it finds one that doesn't exist in the database:
const generateGameCode = async () => {
    let code;
    let exists = true;
    while (exists) {
        code = Math.floor(100000 + Math.random() * 900000).toString();
        const quiz = await Quiz.findOne({ gameCode: code });
        if (!quiz) exists = false;

    }
    return code;
};
Additionally, the gameCode field in our schema has unique: true, so MongoDB will reject any duplicate
codes at the database level.
Q3: How do you handle large files that might crash the server?
A: We have several safeguards:
Text Limiting: We limit extracted text to 10,000 characters:
const cleanText = textContent.substring(0, 10000);
Multer Configuration: We can add file size limits:
const upload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit
});
Validation: We check if the file has enough content:
if (!textContent || textContent.trim().length < 50) {
    throw new Error("File doesn't contain enough text");
}
Q4: What if the AI generates incorrect questions?
A: Teachers can review and edit all AI-generated questions before saving. The frontend displays the
questions in an editable form, so teachers can:
• Modify question text
• Change options
• Update the correct answer
• Adjust timer and points
This ensures quality control while still benefiting from AI speed.
Q5: How is the quiz linked to the teacher who created it?
A: We use MongoDB references. The Quiz schema has a creator field:
creator: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
}
When creating a quiz, we set this to the logged-in user's ID:
const quiz = await Quiz.create({
    // ... other fields
    creator: req.user._id, // From auth middleware
});
This creates a relationship between the Quiz and User collections.

Q6: Explain the difference between embedded and referenced documents in your schema.
A: Great question! In our Quiz model:
Embedded: questions array is embedded directly in the quiz document
questions: [questionSchema] // Stored inside the quiz
• Pros: Faster to retrieve (one query), questions always with quiz
• Cons: Document size limit (16MB in MongoDB)
• Use case: Questions are always accessed with the quiz
Referenced: creator is a reference to a User document
creator: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
}
• Pros: No duplication, user data stays consistent
• Cons: Requires population or separate query
• Use case: User data is shared across multiple quizzes
Conceptual Questions
Q7: Why did you choose Google Gemini over other AI models like ChatGPT?
A: Several reasons:
Free tier: Gemini has a generous free tier for development
JSON mode: Gemini is good at returning structured data
Speed: Fast response times for our use case
Google Cloud integration: Easy to scale if needed
However, the architecture is flexible - we could swap to another AI provider by just changing the
aiGenerator.js file.
Q8: How would you improve this system?
A: Several improvements I'd suggest:
Caching: Cache AI responses for common topics to save API calls
Batch processing: Allow teachers to generate multiple quizzes at once
Question bank: Save generated questions to a reusable library
PDF support: Add PDF text extraction (currently only DOCX)
Image support: Allow questions with images
Difficulty validation: Use AI to verify question difficulty matches the requested level
Plagiarism check: Ensure AI doesn't copy questions from the source document verbatim

Q9: What security concerns should we be aware of?
A: Important security considerations:
API Key Protection: Never expose Gemini API key in frontend
- Stored in .env file
- Only backend has access
File Upload Validation:
- Check file type (MIME type)
- Limit file size
- Scan for malicious content
Authorization:
- Only faculty can create quizzes
- Only creator can edit/delete their quiz
Input Sanitization:
- Validate topic length
- Clean extracted text
- Prevent injection attacks
Rate Limiting:
- Limit AI generation requests per user
- Prevent API abuse
Demo Script
Preparation (Before Presentation)
Ensure backend is running (npm start in backend folder)
Ensure frontend is running (npm run dev in frontend folder)
Ensure MongoDB is running (docker-compose up -d)
Have a test DOCX file ready
Clear any test quizzes from database
Have Postman or browser DevTools ready
Demo 1: Topic-Based Generation (2 minutes)
Script:
"Let me show you how teachers can create a quiz using AI."

Navigate to Faculty Dashboard Create Quiz
"First, I'll enter a title: 'JavaScript Basics Quiz'"
"Now I'll select the Topic mode"
"I'll enter the topic: 'JavaScript Promises'"
"Set difficulty to Medium"
"And request 5 questions"
"Now I'll click Generate with AI..."
[Wait for loading - about 3-5 seconds]
"And here we have 5 AI-generated questions!"
"Notice each question has 4 options, a correct answer, and default timer of 30 seconds"
"Teachers can edit any question if needed. Let me change this first option..."
[Edit one option to show it's editable]
"Now I'll save the quiz..."
[Click Save]
"And we're back at the dashboard. Here's our new quiz with game code 482719"
Demo 2: File-Based Generation (1.5 minutes)
Script:
"Now let me show file-based generation"
Navigate to Create Quiz
"I'll select File mode this time"
"I have a DOCX file about React Hooks"
[Upload file]
"The file is uploaded - 1.2 MB"
"Click Generate with AI..."
[Wait for processing]
"The AI has read the document and generated relevant questions!"
"Notice how the questions are specifically about the content in the document"
Demo 3: Show Database (30 seconds)
Script:
Open MongoDB Compass or use CLI
"Let me show you what this looks like in the database"
Navigate to quizzes collection
"Here's our quiz document with all the questions embedded"
"Notice the gameCode field - this is what students will use to join"

"And the creator field links to the teacher's user ID"
Demo 4: API Testing with Postman (Optional, 1 minute)
Script:
Open Postman
"Let me show you the API endpoint directly"
Create POST request to http://localhost:5000/api/quizzes/generate
Add body:
{
  "mode": "topic",
  "topic": "Python Lists",
  "difficulty": "easy",
  "numQuestions": 3
}
"Send the request..."
"And we get back 3 questions in JSON format"
Troubleshooting Guide
Common Issues & Solutions
Issue 1: "AI Generation Failed"
Possible Causes:
Invalid API key
API rate limit exceeded
Network issues
Invalid prompt
Solutions:
Check .env file has correct GEMINI_API_KEY
Verify API key at Google AI Studio
Check internet connection
Test API key with a simple curl command:
curl -X POST \
  "https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent?key=YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"contents":[{"parts":[{"text":"Say hello"}]}]}'
Issue 2: "File Upload Failed"
Possible Causes:
Unsupported file type
File too large

Corrupted file
Multer not configured
Solutions:
Verify file is .docx format
Check file size (should be < 5MB)
Try a different file
Check Multer configuration in quizRoutes.js:
const upload = multer({ storage: multer.memoryStorage() });
Issue 3: "Quiz Not Saving"
Possible Causes:
MongoDB not running
Validation errors
Missing required fields
Duplicate game code
Solutions:
Check MongoDB is running: docker ps
Check browser console for validation errors
Ensure all questions have text, options, and correct answer
Check backend logs for errors
Issue 4: "Cannot Find Quiz by Game Code"
Possible Causes:
Quiz not published (isPublished: false)
Wrong game code
Quiz deleted
Solutions:
Check quiz document in database
Verify isPublished field is true
Double-check game code
Additional Resources
Video Tutorials
Node.js & Express Tutorial - 8 hours

MongoDB Crash Course - 30 minutes
REST API Design Best Practices - 20 minutes
Google Gemini API Tutorial - 15 minutes
Documentation
• Express.js Guide
• Mongoose Docs
• Google AI Docs
• Multer GitHub
• Mammoth.js GitHub
Practice Projects
Build a blog API with CRUD operations
Create a file upload service
Build a chatbot using Gemini API
Create a quiz app (simpler version)
Final Checklist
Before Presentation Day
Technical Preparation:
• [ ] Project runs without errors
• [ ] All 3 quiz creation methods work
• [ ] Database has sample data
• [ ] API key is valid and working
• [ ] Backup demo video recorded (in case of live demo failure)
Knowledge Preparation:
• [ ] Can explain every line of code in your files
• [ ] Understand how AI integration works
• [ ] Can answer "why" questions (not just "what")
• [ ] Practiced explaining to a non-technical person
• [ ] Prepared for common questions
Presentation Preparation:
• [ ] Slides created (10-12 slides)
• [ ] Demo practiced 3+ times
• [ ] Timing checked (should be 12-13 minutes, leaving 2-3 for Q&A;)
• [ ] Code snippets prepared and tested

• [ ] Backup plan if demo fails
Day Before:
• [ ] Test entire application end-to-end
• [ ] Charge laptop fully
• [ ] Have backup power source
• [ ] Print slides as backup
• [ ] Get good sleep!
Conclusion
You have an exciting and challenging role! Quiz Management & AI Integration is the core functionality of
the application. Your work directly impacts how teachers create content and how students experience the
quizzes.
Key Takeaways:
You handle 3 quiz creation methods: Manual, Topic-based AI, File-based AI
You integrate Google Gemini AI for intelligent question generation
You manage the complete quiz lifecycle (Create, Read, Update, Delete)
You ensure data integrity and security
You provide a seamless API for the frontend
Remember:
• Focus on understanding the flow of data through the system
• Practice explaining concepts in simple terms
• Be ready to demo your work confidently
• Prepare for "what if" questions
• Show enthusiasm for the AI integration aspect
Good luck with your presentation! You've got this!
*Document created for Member 2 of the KMIT Kahoot Clone project*
*Last updated: February 13, 2026*